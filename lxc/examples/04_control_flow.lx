# Control Flow Examples
# Demonstrates various control flow constructs in Lx

def if_else_examples() do
  age = 25
  score = 85

  # Basic if/else
  age_status = if age >= 18 do
    "Adult"
  else
    "Minor"
  end

  # Nested if/else
  grade = if score >= 90 do
    "A"
  else
    if score >= 80 do
      "B"
    else
      if score >= 70 do
        "C"
      else
        "F"
      end
    end
  end

  {age_status, grade}
end

def case_examples() do
  # Basic case with pattern matching
  status = :ok
  status_message = case status do
    :ok -> "Success"
    :error -> "Error occurred"
    :timeout -> "Operation timed out"
    _ -> "Unknown status"
  end

  # Case with complex patterns
  data = {:user, "Alice", 30}
  user_info = case data do
    {:user, name, age} -> "User: " ++ name ++ " (" ++ integer_to_string(age) ++ ")"
    {:admin, name, level} -> "Admin: " ++ name ++ " (Level " ++ integer_to_string(level) ++ ")"
    {:guest, name} -> "Guest: " ++ name
    _ -> "Unknown user type"
  end

  # Case with guards
  number = 15
  number_type = case number do
    n when n < 0 -> "Negative"
    n when n == 0 -> "Zero"
    n when n > 0 andalso n < 10 -> "Single digit positive"
    n when n >= 10 andalso n < 100 -> "Double digit positive"
    _ -> "Large positive number"
  end

  {status_message, user_info, number_type}
end

def with_expressions() do
  # Basic with expression
  user_data = %{name: "Bob", age: 25}

  result1 = with {:ok, name} <= get_name(user_data) do
    "Hello, " ++ name
  else
    "Unknown user"
  end

  # With expression with pattern matching
  result2 = with {:ok, name} <= get_name(user_data) do
    "Hello, " ++ name
  case
    {:error, :not_found} -> "User not found"
    {:error, reason} when reason == :timeout -> "Request timeout"
    {:error, _} -> "Unknown error"
    _ -> "Unexpected result"
  end

  # Multiple with steps
  result3 = with {:ok, user} <= get_user(123),
                 {:ok, role} <= get_role(user) do
    {user.name, role}
  else
    {:error, "Failed to get user or role"}
  end

  # With without else (returns optional)
  result4 = with {:ok, name} <= get_name(user_data) do
    "Hello, " ++ name
  end

  {result1, result2, result3, result4}
end

def match_rescue_examples() do
  # Individual match rescue steps
  step1 = match {:ok, user} <- get_user(123) rescue { :user_not_found }
  step2 = match {:ok, perms} <- get_permissions(user) rescue { :permission_error }

  # Sequential match rescue
  result = do
    match {:ok, user} <- get_user(123) rescue { :user_error }
    match {:ok, perms} <- get_permissions(user) rescue { :permission_error }
    :success
  end

  # Pattern matching in match rescue
  data = %{name: "Alice", age: 30}
  extracted = match %{name: user_name, age: user_age} <- data rescue { %{name: "unknown", age: 0} }

  {step1, step2, result, extracted}
end

def for_loop_examples() do
  # Simple for loop
  numbers = [1, 2, 3, 4, 5]
  doubled = for x in numbers do
    x * 2
  end

  # For loop with guard
  even_numbers = for x in numbers when x % 2 == 0 do
    x
  end

  # Complex pattern matching in for loops
  users = [
    %{name: "Alice", age: 25},
    %{name: "Bob", age: 30},
    %{name: "Charlie", age: 35}
  ]

  adult_names = for %{name: name} = user in users when user.age >= 18 do
    name
  end

  # Multiple pattern types
  pairs = [{"a", 1}, {"b", 2}, {"c", 3}]
  keys = for {key, value} in pairs when value > 1 do
    key
  end

  {doubled, even_numbers, adult_names, keys}
end

def nested_control_flow() do
  # Complex nested control flow
  data = [
    {:user, "Alice", 25},
    {:admin, "Bob", 2},
    {:guest, "Charlie"},
    {:user, "David", 17}
  ]

  processed = for item in data do
    case item do
      {:user, name, age} when age >= 18 ->
        "Adult user: " ++ name
      {:user, name, age} when age < 18 ->
        "Minor user: " ++ name
      {:admin, name, level} when level >= 3 ->
        "Senior admin: " ++ name
      {:admin, name, level} when level < 3 ->
        "Junior admin: " ++ name
      {:guest, name} ->
        "Guest: " ++ name
      _ ->
        "Unknown: " ++ "unknown"
    end
  end

  processed
end

def error_handling_patterns() do
  # Error handling with case
  result1 = case risky_operation() do
    {:ok, data} -> "Success: " ++ data
    {:error, reason} -> "Error: " ++ reason
    _ -> "Unknown result"
  end

  # Error handling with with expression
  result2 = with {:ok, data} <= risky_operation() do
    "Success: " ++ data
  else
    "Operation failed"
  end

  # Error handling with match rescue
  result3 = match {:ok, data} <- risky_operation() rescue { "Operation failed" }

  {result1, result2, result3}
end

# Mock functions for demonstration
defp get_name(user_data) do
  case user_data do
    %{name: name} -> {:ok, name}
    _ -> {:error, :not_found}
  end
end

defp get_user(id) do
  if id == 123 do
    {:ok, %{name: "Test User", id: 123}}
  else
    {:error, :not_found}
  end
end

defp get_role(user) do
  {:ok, "admin"}
end

defp get_permissions(user) do
  {:ok, ["read", "write"]}
end

defp risky_operation() do
  # Simulate a risky operation that might fail
  if random_bool() do
    {:ok, "operation succeeded"}
  else
    {:error, "operation failed"}
  end
end

defp random_bool() do
  # Simulate random boolean
  true
end

defp integer_to_string(n) do
  "number"
end