# Concurrency Examples
# Demonstrates message passing, receive expressions, and concurrent patterns in Lx

def basic_message_passing() do
  # Send messages to processes
  pid = spawn(fn() do receiver_process() end)

  # Send different types of messages
  pid ! {:hello, "world"}
  pid ! {:data, [1, 2, 3, 4, 5]}
  pid ! :ping
  pid ! {:calculate, 10, 20}

  "Messages sent"
end

def receiver_process() do
  receive do
    {:hello, message} ->
      "Received hello: " ++ message
    {:data, data} ->
      "Received data: " ++ list_to_string(data)
    :ping ->
      "Received ping"
    {:calculate, a, b} ->
      result = a + b
      "Calculated: " ++ integer_to_string(result)
    _ ->
      "Unknown message"
  end
end

def echo_server() do
  # Simple echo server that responds to messages
  echo_server_loop()
end

def echo_server_loop() do
  receive do
    {:echo, message, from} ->
      from ! {:response, message}
      echo_server_loop()
    :stop ->
      "Echo server stopped"
    _ ->
      echo_server_loop()
  end
end

def counter_process() do
  # Stateful counter process
  counter_loop(0)
end

def counter_loop(count) do
  receive do
    :increment ->
      counter_loop(count + 1)
    :decrement ->
      counter_loop(count - 1)
    {:get, from} ->
      from ! {:count, count}
      counter_loop(count)
    :reset ->
      counter_loop(0)
    :stop ->
      "Counter stopped at " ++ integer_to_string(count)
  end
end

def chat_room() do
  # Chat room with multiple participants
  chat_room_loop([])
end

def chat_room_loop(participants) do
  receive do
    {:join, user_name, pid} ->
      new_participants = [{user_name, pid} | participants]
      broadcast_message(new_participants, user_name ++ " joined the chat")
      chat_room_loop(new_participants)
    {:leave, user_name, pid} ->
      new_participants = remove_participant(participants, pid)
      broadcast_message(new_participants, user_name ++ " left the chat")
      chat_room_loop(new_participants)
    {:message, user_name, message, pid} ->
      broadcast_message(participants, user_name ++ ": " ++ message)
      chat_room_loop(participants)
    :list_participants ->
      participant_names = for {name, _pid} in participants do
        name
      end
      "Participants: " ++ list_to_string(participant_names)
  end
end

def broadcast_message(participants, message) do
  for {_name, pid} in participants do
    pid ! {:chat_message, message}
  end
  "Message broadcasted"
end

def remove_participant(participants, target_pid) do
  case participants do
    [] -> []
    [{name, pid} | rest] ->
      if pid == target_pid do
        rest
      else
        [{name, pid} | remove_participant(rest, target_pid)]
      end
  end
end

def worker_pool() do
  # Worker pool with multiple workers
  pool_size = 3
  workers = spawn_workers(pool_size, [])
  worker_pool_loop(workers, [])
end

def spawn_workers(0, workers) do
  workers
end

def spawn_workers(count, workers) do
  worker_pid = spawn(fn() do worker_process() end)
  spawn_workers(count - 1, [worker_pid | workers])
end

def worker_pool_loop(workers, queue) do
  receive do
    {:task, task_data, from} ->
      case workers do
        [] ->
          # No workers available, add to queue
          worker_pool_loop(workers, [{task_data, from} | queue])
        [worker | rest_workers] ->
          # Send task to available worker
          worker ! {:process, task_data, from}
          worker_pool_loop(rest_workers, queue)
      end
    {:worker_ready, worker_pid} ->
      case queue do
        [] ->
          # No tasks in queue, add worker back to pool
          worker_pool_loop([worker_pid | workers], [])
        [{task_data, from} | rest_queue] ->
          # Send queued task to worker
          worker_pid ! {:process, task_data, from}
          worker_pool_loop(workers, rest_queue)
      end
    :stop ->
      # Stop all workers
      for worker in workers do
        worker ! :stop
      end
      "Worker pool stopped"
  end
end

def worker_process() do
  receive do
    {:process, task_data, from} ->
      # Process the task
      result = process_task(task_data)
      from ! {:result, result}
      # Signal that worker is ready for next task
      self() ! {:worker_ready, self()}
      worker_process()
    :stop ->
      "Worker stopped"
  end
end

def process_task(task_data) do
  # Simulate task processing
  case task_data do
    {:add, a, b} -> a + b
    {:multiply, a, b} -> a * b
    {:reverse, text} -> reverse_string(text)
    _ -> "Unknown task"
  end
end

def timeout_examples() do
  # Receive with timeout
  result = receive do
    :message -> "Received message"
  after 5000 do
    :timeout
  end

  # Multiple timeouts
  result2 = receive do
    :urgent -> "Urgent message"
  after 1000 do
    receive do
      :normal -> "Normal message"
    after 4000 do
      :timeout
    end
  end

  {result, result2}
end

def selective_receive() do
  # Selective message handling
  receive do
    {:priority, high} when high > 10 ->
      "High priority message"
    {:priority, low} when low <= 10 ->
      "Low priority message"
    {:data, data} when is_list(data) ->
      "List data received"
    {:data, data} when is_map(data) ->
      "Map data received"
    _ ->
      "Unknown message"
  end
end

def process_monitoring() do
  # Monitor a process
  target_pid = spawn(fn() do monitored_process() end)

  # Monitor the process
  ref = monitor_process(target_pid)

  # Send some messages
  target_pid ! :work
  target_pid ! :stop

  # Wait for monitoring messages
  receive do
    {:DOWN, ^ref, :process, ^target_pid, reason} ->
      "Process terminated: " ++ atom_to_string(reason)
  end
end

def monitored_process() do
  receive do
    :work ->
      "Working..."
      monitored_process()
    :stop ->
      "Stopping"
      exit(:normal)
  end
end

def process_linking() do
  # Create linked processes
  parent_pid = spawn_link(fn() do parent_process() end)

  # Send message to parent
  parent_pid ! :start_child

  "Parent process started"
end

def parent_process() do
  receive do
    :start_child ->
      child_pid = spawn_link(fn() do child_process() end)
      "Child process started"
      parent_process()
    {:EXIT, child_pid, reason} ->
      "Child process exited: " ++ atom_to_string(reason)
      parent_process()
  end
end

def child_process() do
  receive do
    :work ->
      "Child working..."
      child_process()
    :crash ->
      exit(:abnormal)
  end
end

# Helper functions
defp list_to_string(list) do
  case list do
    [] -> "[]"
    [head | tail] -> "[" ++ integer_to_string(head) ++ list_to_string_helper(tail) ++ "]"
  end
end

defp list_to_string_helper(list) do
  case list do
    [] -> ""
    [head | tail] -> ", " ++ integer_to_string(head) ++ list_to_string_helper(tail)
  end
end

defp reverse_string(text) do
  case text do
    "" -> ""
    <<char::utf8, rest::binary>> -> reverse_string(rest) ++ <<char::utf8>>
  end
end

defp monitor_process(pid) do
  # Mock process monitoring
  :mock_ref
end

defp spawn_link(fun) do
  # Mock spawn_link
  spawn(fun)
end

defp atom_to_string(atom) do
  case atom do
    :normal -> "normal"
    :abnormal -> "abnormal"
    _ -> "unknown"
  end
end

defp integer_to_string(n) do
  "number"
end