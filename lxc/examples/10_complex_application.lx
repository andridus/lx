# Complex Application Example
# Demonstrates a complete web API server with database, caching, and monitoring

# Dependencies
deps [:cowboy, :jsx, :crypto]

# Application definition
application {
  description "E-commerce API Server"
  vsn "1.0.0"
  applications [kernel, stdlib, cowboy]
  registered [api_server, product_manager, order_manager, user_manager, cache_manager]
  env [
    port: 8080,
    database_url: "localhost:5432",
    cache_ttl: 3600,
    max_connections: 1000
  ]
}

# Record definitions
record Product do
  id :: string,
  name :: string,
  description :: string,
  price :: float,
  stock :: integer,
  category :: string,
  created_at :: integer
end

record User do
  id :: string,
  name :: string,
  email :: string,
  password_hash :: string,
  role :: string,
  created_at :: integer
end

record Order do
  id :: string,
  user_id :: string,
  products :: list,
  total :: float,
  status :: string,
  created_at :: integer
end

record OrderItem do
  product_id :: string,
  quantity :: integer,
  price :: float
end

# Main API Server Worker
worker api_server do
  def init(_) do
    # Initialize HTTP server
    port = get_env(:port, 8080)
    {:ok, %{port: port, routes: initialize_routes()}}
  end

  def handle_call({:start_server}, _from, state) do
    %{port: port, routes: routes} <- state
    start_http_server(port, routes)
    {:reply, :ok, state}
  end

  def handle_call({:handle_request, method, path, headers, body}, _from, state) do
    %{routes: routes} <- state
    response = route_request(method, path, headers, body, routes)
    {:reply, response, state}
  end

  def handle_info({:http_request, method, path, headers, body}, state) do
    %{routes: routes} <- state
    response = route_request(method, path, headers, body, routes)
    # Send response back to client
    {:noreply, state}
  end

  def terminate(_reason, _state) do
    :ok
  end
end

# Product Management Worker
worker product_manager do
  def init(_) do
    {:ok, %{products: %{}, next_id: 1}}
  end

  def handle_call({:create_product, product_data}, _from, state) do
    %{products: products, next_id: next_id} <- state

    # Validate product data
    case validate_product(product_data) do
      {:ok, validated_product} ->
        product_id = "prod_" ++ integer_to_string(next_id)
        new_product = %{
          id: product_id,
          name: validated_product.name,
          description: validated_product.description,
          price: validated_product.price,
          stock: validated_product.stock,
          category: validated_product.category,
          created_at: now()
        }

        new_products = %{product_id => new_product | products}
        new_state = %{state | products: new_products, next_id: next_id + 1}

        # Update cache
        cache_manager ! {:put, "product:" ++ product_id, new_product}

        {:reply, {:ok, new_product}, new_state}
      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call({:get_product, product_id}, _from, state) do
    %{products: products} <- state

    case products[product_id] do
      nil -> {:reply, {:error, :not_found}, state}
      product -> {:reply, {:ok, product}, state}
    end
  end

  def handle_call({:list_products, filters}, _from, state) do
    %{products: products} <- state

    filtered_products = filter_products(products, filters)
    {:reply, {:ok, filtered_products}, state}
  end

  def handle_call({:update_product, product_id, updates}, _from, state) do
    %{products: products} <- state

    case products[product_id] do
      nil -> {:reply, {:error, :not_found}, state}
      product ->
        updated_product = %{product | updates}
        new_products = %{product_id => updated_product | products}
        new_state = %{state | products: new_products}

        # Update cache
        cache_manager ! {:put, "product:" ++ product_id, updated_product}

        {:reply, {:ok, updated_product}, new_state}
    end
  end

  def handle_call({:delete_product, product_id}, _from, state) do
    %{products: products} <- state

    case products[product_id] do
      nil -> {:reply, {:error, :not_found}, state}
      _product ->
        new_products = remove_product(products, product_id)
        new_state = %{state | products: new_products}

        # Remove from cache
        cache_manager ! {:remove, "product:" ++ product_id}

        {:reply, :ok, new_state}
    end
  end

  def handle_call({:update_stock, product_id, quantity}, _from, state) do
    %{products: products} <- state

    case products[product_id] do
      nil -> {:reply, {:error, :not_found}, state}
      product ->
        new_stock = product.stock + quantity
        if new_stock >= 0 do
          updated_product = %{product | stock: new_stock}
          new_products = %{product_id => updated_product | products}
          new_state = %{state | products: new_products}

          # Update cache
          cache_manager ! {:put, "product:" ++ product_id, updated_product}

          {:reply, {:ok, updated_product}, new_state}
        else
          {:reply, {:error, :insufficient_stock}, state}
        end
    end
  end
end

# Order Management Worker
worker order_manager do
  def init(_) do
    {:ok, %{orders: %{}, next_id: 1}}
  end

  def handle_call({:create_order, user_id, items}, _from, state) do
    %{orders: orders, next_id: next_id} <- state

    # Validate order items and calculate total
    case validate_order_items(items) do
      {:ok, validated_items, total} ->
        order_id = "order_" ++ integer_to_string(next_id)
        new_order = %{
          id: order_id,
          user_id: user_id,
          products: validated_items,
          total: total,
          status: "pending",
          created_at: now()
        }

        # Update product stock
        update_product_stock(validated_items)

        new_orders = %{order_id => new_order | orders}
        new_state = %{state | orders: new_orders, next_id: next_id + 1}

        {:reply, {:ok, new_order}, new_state}
      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call({:get_order, order_id}, _from, state) do
    %{orders: orders} <- state

    case orders[order_id] do
      nil -> {:reply, {:error, :not_found}, state}
      order -> {:reply, {:ok, order}, state}
    end
  end

  def handle_call({:list_user_orders, user_id}, _from, state) do
    %{orders: orders} <- state

    user_orders = for {_id, order} in orders when order.user_id == user_id do
      order
    end

    {:reply, {:ok, user_orders}, state}
  end

  def handle_call({:update_order_status, order_id, status}, _from, state) do
    %{orders: orders} <- state

    case orders[order_id] do
      nil -> {:reply, {:error, :not_found}, state}
      order ->
        updated_order = %{order | status: status}
        new_orders = %{order_id => updated_order | orders}
        new_state = %{state | orders: new_orders}

        {:reply, {:ok, updated_order}, new_state}
    end
  end
end

# User Management Worker
worker user_manager do
  def init(_) do
    {:ok, %{users: %{}, next_id: 1}}
  end

  def handle_call({:create_user, user_data}, _from, state) do
    %{users: users, next_id: next_id} <- state

    # Validate user data
    case validate_user_data(user_data) do
      {:ok, validated_user} ->
        user_id = "user_" ++ integer_to_string(next_id)
        password_hash = hash_password(validated_user.password)

        new_user = %{
          id: user_id,
          name: validated_user.name,
          email: validated_user.email,
          password_hash: password_hash,
          role: "customer",
          created_at: now()
        }

        new_users = %{user_id => new_user | users}
        new_state = %{state | users: new_users, next_id: next_id + 1}

        {:reply, {:ok, new_user}, new_state}
      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  def handle_call({:authenticate_user, email, password}, _from, state) do
    %{users: users} <- state

    user = find_user_by_email(users, email)
    case user do
      nil -> {:reply, {:error, :user_not_found}, state}
      found_user ->
        if verify_password(password, found_user.password_hash) do
          {:reply, {:ok, found_user}, state}
        else
          {:reply, {:error, :invalid_password}, state}
        end
    end
  end

  def handle_call({:get_user, user_id}, _from, state) do
    %{users: users} <- state

    case users[user_id] do
      nil -> {:reply, {:error, :not_found}, state}
      user -> {:reply, {:ok, user}, state}
    end
  end
end

# Cache Manager Worker
worker cache_manager do
  def init(_) do
    ttl = get_env(:cache_ttl, 3600)
    {:ok, %{cache: %{}, ttl: ttl}}
  end

  def handle_call({:get, key}, _from, state) do
    %{cache: cache, ttl: ttl} <- state
    current_time = now()

    case cache[key] do
      nil -> {:reply, {:error, :not_found}, state}
      {value, timestamp} ->
        if current_time - timestamp < ttl do
          {:reply, {:ok, value}, state}
        else
          # Expired, remove from cache
          new_cache = remove_cache_entry(cache, key)
          new_state = %{state | cache: new_cache}
          {:reply, {:error, :expired}, new_state}
        end
    end
  end

  def handle_call({:put, key, value}, _from, state) do
    %{cache: cache, ttl: ttl} <- state
    current_time = now()

    updated_cache = %{key => {value, current_time} | cache}
    new_state = %{state | cache: updated_cache}

    {:reply, :ok, new_state}
  end

  def handle_call({:remove, key}, _from, state) do
    %{cache: cache} <- state
    new_cache = remove_cache_entry(cache, key)
    new_state = %{state | cache: new_cache}

    {:reply, :ok, new_state}
  end

  def handle_call(:clear, _from, state) do
    new_state = %{state | cache: %{}}
    {:reply, :ok, new_state}
  end

  def handle_cast({:cleanup_expired}, state) do
    %{cache: cache, ttl: ttl} <- state
    current_time = now()

    {new_cache, _expired_count} = cleanup_expired_entries(cache, current_time, ttl)
    new_state = %{state | cache: new_cache}

    {:noreply, new_state}
  end
end

# Supervisor for the application
supervisor ecommerce_supervisor do
  strategy one_for_one
  children [
    api_server,
    product_manager,
    order_manager,
    user_manager,
    cache_manager
  ]
end

# Helper functions
defp initialize_routes() do
  %{
    "GET" => %{
      "/api/products" => &list_products_handler/4,
      "/api/products/:id" => &get_product_handler/4,
      "/api/orders/:id" => &get_order_handler/4,
      "/api/users/:id" => &get_user_handler/4
    },
    "POST" => %{
      "/api/products" => &create_product_handler/4,
      "/api/orders" => &create_order_handler/4,
      "/api/users" => &create_user_handler/4,
      "/api/auth/login" => &login_handler/4
    },
    "PUT" => %{
      "/api/products/:id" => &update_product_handler/4,
      "/api/orders/:id/status" => &update_order_status_handler/4
    },
    "DELETE" => %{
      "/api/products/:id" => &delete_product_handler/4
    }
  }
end

defp route_request(method, path, headers, body, routes) do
  method_routes = routes[method]
  case method_routes do
    nil -> {:error, 405, "Method not allowed"}
    _ ->
      handler = find_handler(method_routes, path)
      case handler do
        nil -> {:error, 404, "Not found"}
        found_handler -> found_handler(method, path, headers, body)
      end
  end
end

defp find_handler(routes, path) do
  # Simple path matching - in a real implementation, use proper routing
  routes[path]
end

# HTTP Handlers
defp list_products_handler(_method, _path, _headers, _body) do
  case product_manager.call({:list_products, %{}}) do
    {:ok, products} -> {:ok, 200, encode_json(products)}
    {:error, reason} -> {:error, 500, reason}
  end
end

defp get_product_handler(_method, path, _headers, _body) do
  product_id = extract_id_from_path(path)
  case product_manager.call({:get_product, product_id}) do
    {:ok, product} -> {:ok, 200, encode_json(product)}
    {:error, :not_found} -> {:error, 404, "Product not found"}
    {:error, reason} -> {:error, 500, reason}
  end
end

defp create_product_handler(_method, _path, _headers, body) do
  product_data = decode_json(body)
  case product_manager.call({:create_product, product_data}) do
    {:ok, product} -> {:ok, 201, encode_json(product)}
    {:error, reason} -> {:error, 400, reason}
  end
end

defp update_product_handler(_method, path, _headers, body) do
  product_id = extract_id_from_path(path)
  updates = decode_json(body)
  case product_manager.call({:update_product, product_id, updates}) do
    {:ok, product} -> {:ok, 200, encode_json(product)}
    {:error, :not_found} -> {:error, 404, "Product not found"}
    {:error, reason} -> {:error, 400, reason}
  end
end

defp delete_product_handler(_method, path, _headers, _body) do
  product_id = extract_id_from_path(path)
  case product_manager.call({:delete_product, product_id}) do
    :ok -> {:ok, 204, ""}
    {:error, :not_found} -> {:error, 404, "Product not found"}
    {:error, reason} -> {:error, 500, reason}
  end
end

defp create_order_handler(_method, _path, _headers, body) do
  order_data = decode_json(body)
  case order_manager.call({:create_order, order_data.user_id, order_data.items}) do
    {:ok, order} -> {:ok, 201, encode_json(order)}
    {:error, reason} -> {:error, 400, reason}
  end
end

defp get_order_handler(_method, path, _headers, _body) do
  order_id = extract_id_from_path(path)
  case order_manager.call({:get_order, order_id}) do
    {:ok, order} -> {:ok, 200, encode_json(order)}
    {:error, :not_found} -> {:error, 404, "Order not found"}
    {:error, reason} -> {:error, 500, reason}
  end
end

defp update_order_status_handler(_method, path, _headers, body) do
  order_id = extract_id_from_path(path)
  status_data = decode_json(body)
  case order_manager.call({:update_order_status, order_id, status_data.status}) do
    {:ok, order} -> {:ok, 200, encode_json(order)}
    {:error, :not_found} -> {:error, 404, "Order not found"}
    {:error, reason} -> {:error, 400, reason}
  end
end

defp create_user_handler(_method, _path, _headers, body) do
  user_data = decode_json(body)
  case user_manager.call({:create_user, user_data}) do
    {:ok, user} -> {:ok, 201, encode_json(user)}
    {:error, reason} -> {:error, 400, reason}
  end
end

defp get_user_handler(_method, path, _headers, _body) do
  user_id = extract_id_from_path(path)
  case user_manager.call({:get_user, user_id}) do
    {:ok, user} -> {:ok, 200, encode_json(user)}
    {:error, :not_found} -> {:error, 404, "User not found"}
    {:error, reason} -> {:error, 500, reason}
  end
end

defp login_handler(_method, _path, _headers, body) do
  login_data = decode_json(body)
  case user_manager.call({:authenticate_user, login_data.email, login_data.password}) do
    {:ok, user} -> {:ok, 200, encode_json(%{user: user, token: generate_token(user)})}
    {:error, reason} -> {:error, 401, reason}
  end
end

# Validation functions
defp validate_product(product_data) do
  if product_data.name == "" do
    {:error, "Product name cannot be empty"}
  else
    if product_data.price <= 0 do
      {:error, "Product price must be positive"}
    else
      if product_data.stock < 0 do
        {:error, "Product stock cannot be negative"}
      else
        {:ok, product_data}
      end
    end
  end
end

defp validate_order_items(items) do
  case validate_items_helper(items, [], 0.0) do
    {:ok, validated_items, total} -> {:ok, validated_items, total}
    {:error, reason} -> {:error, reason}
  end
end

defp validate_items_helper([], validated_items, total) do
  {:ok, validated_items, total}
end

defp validate_items_helper([item | rest], validated_items, total) do
  case product_manager.call({:get_product, item.product_id}) do
    {:ok, product} ->
      if product.stock >= item.quantity do
        item_total = product.price * item.quantity
        validated_item = %{
          product_id: item.product_id,
          quantity: item.quantity,
          price: product.price
        }
        validate_items_helper(rest, [validated_item | validated_items], total + item_total)
      else
        {:error, "Insufficient stock for product " ++ item.product_id}
      end
    {:error, :not_found} ->
      {:error, "Product not found: " ++ item.product_id}
  end
end

defp validate_user_data(user_data) do
  if user_data.name == "" do
    {:error, "Name cannot be empty"}
  else
    if user_data.email == "" do
      {:error, "Email cannot be empty"}
    else
      if user_data.password == "" do
        {:error, "Password cannot be empty"}
      else
        {:ok, user_data}
      end
    end
  end
end

# Utility functions
defp now() do
  # Mock timestamp
  1234567890
end

defp hash_password(password) do
  # Mock password hashing
  "hashed_" ++ password
end

defp verify_password(password, hash) do
  # Mock password verification
  "hashed_" ++ password == hash
end

defp generate_token(user) do
  # Mock token generation
  "token_" ++ user.id
end

defp update_product_stock(items) do
  for item in items do
    product_manager.call({:update_stock, item.product_id, -item.quantity})
  end
  :ok
end

defp filter_products(products, filters) do
  # Simple filtering - in a real implementation, use proper filtering
  products
end

defp remove_product(products, product_id) do
  case products do
    %{} -> %{}
    %{product_id => _value | rest} -> rest
    %{key => value | rest} -> %{key => value | remove_product(rest, product_id)}
  end
end

defp find_user_by_email(users, email) do
  case users do
    %{} -> nil
    %{_id => user | rest} ->
      if user.email == email do
        user
      else
        find_user_by_email(rest, email)
      end
  end
end

defp remove_cache_entry(cache, key) do
  case cache do
    %{} -> %{}
    %{key => _value | rest} -> rest
    %{k => v | rest} -> %{k => v | remove_cache_entry(rest, key)}
  end
end

defp cleanup_expired_entries(cache, current_time, ttl) do
  cleanup_expired_helper(cache, current_time, ttl, %{}, 0)
end

defp cleanup_expired_helper(cache, current_time, ttl, valid_cache, expired_count) do
  case cache do
    %{} -> {valid_cache, expired_count}
    %{key => {value, timestamp} | rest} ->
      if current_time - timestamp < ttl do
        cleanup_expired_helper(rest, current_time, ttl, %{key => {value, timestamp} | valid_cache}, expired_count)
      else
        cleanup_expired_helper(rest, current_time, ttl, valid_cache, expired_count + 1)
      end
  end
end

defp extract_id_from_path(path) do
  # Simple path extraction - in a real implementation, use proper routing
  "id"
end

defp encode_json(data) do
  # Mock JSON encoding
  "json_encoded_data"
end

defp decode_json(json) do
  # Mock JSON decoding
  %{data: "decoded"}
end

defp start_http_server(port, routes) do
  # Mock HTTP server startup
  "HTTP server started on port " ++ integer_to_string(port)
end

defp get_env(key, default) do
  # Mock environment variable retrieval
  default
end

defp integer_to_string(n) do
  "number"
end