# OTP Components Examples
# Demonstrates workers, supervisors, and OTP patterns in Lx

# Record definitions for state
record UserState do
  users :: list,
  count :: integer
end

record SessionState do
  sessions :: map,
  active_count :: integer
end

# Worker examples
worker user_manager do
  def init(_) do
    {:ok, UserState{users: [], count: 0}}
  end

  def handle_call({:add_user, user}, _from, state) do
    new_users = [user | state.users]
    new_state = {state | users: new_users, count: state.count + 1}
    {:reply, :ok, new_state}
  end

  def handle_call({:get_user, user_id}, _from, state) do
    user = find_user_by_id(state.users, user_id)
    case user do
      nil -> {:reply, {:error, :not_found}, state}
      found_user -> {:reply, {:ok, found_user}, state}
    end
  end

  def handle_call(:get_count, _from, state) do
    {:reply, state.count, state}
  end

  def handle_call(:get_all_users, _from, state) do
    {:reply, state.users, state}
  end

  def handle_cast({:remove_user, user_id}, state) do
    new_users = remove_user_by_id(state.users, user_id)
    new_count = state.count - 1
    new_state = {state | users: new_users, count: new_count}
    {:noreply, new_state}
  end

  def handle_info({:timeout, user_id}, state) do
    # Handle timeout for user session
    new_users = remove_user_by_id(state.users, user_id)
    new_state = {state | users: new_users, count: state.count - 1}
    {:noreply, new_state}
  end

  def terminate(_reason, _state) do
    :ok
  end
end

worker session_manager do
  def init(_) do
    # Initialize state as a map
    initial_state = %{sessions: %{}, active_count: 0}
    {:ok, initial_state}
  end

  def handle_call({:create_session, user_id}, _from, state) do
    # Extract current sessions and count using pattern matching
    %{sessions: current_sessions, active_count: count} <- state

    # Create new session
    session_id = generate_session_id()
    session_data = %{user_id: user_id, created_at: now(), active: true}

    # Update state with new session
    new_sessions = %{session_id => session_data | current_sessions}
    new_state = %{sessions: new_sessions, active_count: count + 1}

    {:reply, {:ok, session_id}, new_state}
  end

  def handle_call({:get_session, session_id}, _from, state) do
    %{sessions: sessions} <- state

    case sessions[session_id] do
      nil -> {:reply, {:error, :not_found}, state}
      session_data -> {:reply, {:ok, session_data}, state}
    end
  end

  def handle_call({:update_session, session_id, updates}, _from, state) do
    %{sessions: sessions, active_count: count} <- state

    case sessions[session_id] do
      nil -> {:reply, {:error, :not_found}, state}
      session_data ->
        # Pattern match to extract session fields and apply updates
        %{user_id: user_id, created_at: created_at} <- session_data
        updated_session = %{
          user_id: user_id,
          created_at: created_at,
          active: updates[:active],
          last_accessed: now()
        }
        new_sessions = %{session_id => updated_session | sessions}
        new_state = %{sessions: new_sessions, active_count: count}
        {:reply, :ok, new_state}
    end
  end

  def handle_call({:close_session, session_id}, _from, state) do
    %{sessions: sessions, active_count: count} <- state

    case sessions[session_id] do
      nil -> {:reply, {:error, :not_found}, state}
      _session_data ->
        new_sessions = remove_session(sessions, session_id)
        new_state = %{sessions: new_sessions, active_count: count - 1}
        {:reply, :ok, new_state}
    end
  end

  def handle_call(:get_active_count, _from, state) do
    %{active_count: count} <- state
    {:reply, count, state}
  end

  def handle_cast({:cleanup_expired}, state) do
    %{sessions: sessions, active_count: count} <- state
    current_time = now()

    # Remove expired sessions (older than 1 hour)
    {new_sessions, expired_count} = cleanup_expired_sessions(sessions, current_time)
    new_state = %{sessions: new_sessions, active_count: count - expired_count}

    {:noreply, new_state}
  end

  def handle_info({:cleanup_timer}, state) do
    # Periodic cleanup
    self() ! {:cleanup_expired}
    {:noreply, state}
  end

  def terminate(_reason, _state) do
    :ok
  end
end

worker cache_manager do
  def init(_) do
    {:ok, %{cache: %{}, max_size: 1000, ttl: 3600}}
  end

  def handle_call({:get, key}, _from, state) do
    %{cache: cache, ttl: ttl} <- state
    current_time = now()

    case cache[key] do
      nil -> {:reply, {:error, :not_found}, state}
      {value, timestamp} ->
        if current_time - timestamp < ttl do
          {:reply, {:ok, value}, state}
        else
          # Expired, remove from cache
          new_cache = remove_cache_entry(cache, key)
          new_state = %{state | cache: new_cache}
          {:reply, {:error, :expired}, new_state}
        end
    end
  end

  def handle_call({:put, key, value}, _from, state) do
    %{cache: cache, max_size: max_size, ttl: ttl} <- state
    current_time = now()

    # Check if cache is full
    cache_size = map_size(cache)
    if cache_size >= max_size do
      # Remove oldest entry
      new_cache = remove_oldest_entry(cache)
    else
      new_cache = cache
    end

    # Add new entry
    updated_cache = %{key => {value, current_time} | new_cache}
    new_state = %{state | cache: updated_cache}

    {:reply, :ok, new_state}
  end

  def handle_call({:remove, key}, _from, state) do
    %{cache: cache} <- state
    new_cache = remove_cache_entry(cache, key)
    new_state = %{state | cache: new_cache}

    {:reply, :ok, new_state}
  end

  def handle_call(:clear, _from, state) do
    new_state = %{state | cache: %{}}
    {:reply, :ok, new_state}
  end

  def handle_call(:stats, _from, state) do
    %{cache: cache, max_size: max_size} <- state
    stats = %{
      size: map_size(cache),
      max_size: max_size,
      utilization: map_size(cache) / max_size
    }
    {:reply, stats, state}
  end

  def terminate(_reason, _state) do
    :ok
  end
end

# Supervisor examples
supervisor top_supervisor do
  strategy one_for_one
  children [
    user_manager,
    session_manager,
    cache_manager
  ]
end

supervisor application_supervisor do
  strategy one_for_all
  children [
    user_manager,
    session_manager
  ]
end

supervisor fault_tolerant_supervisor do
  strategy rest_for_one
  children [
    user_manager,
    session_manager,
    cache_manager
  ]
end

# Helper functions for workers
defp find_user_by_id(users, user_id) do
  case users do
    [] -> nil
    [user | rest] ->
      case user do
        %{id: id} when id == user_id -> user
        _ -> find_user_by_id(rest, user_id)
      end
  end
end

defp remove_user_by_id(users, user_id) do
  case users do
    [] -> []
    [user | rest] ->
      case user do
        %{id: id} when id == user_id -> rest
        _ -> [user | remove_user_by_id(rest, user_id)]
      end
  end
end

defp generate_session_id() do
  # Simple session ID generation
  "session_" ++ integer_to_string(now())
end

defp now() do
  # Mock timestamp function
  1234567890
end

defp remove_session(sessions, session_id) do
  case sessions do
    %{} -> %{}
    %{session_id => _value | rest} -> rest
    %{key => value | rest} -> %{key => value | remove_session(rest, session_id)}
  end
end

defp cleanup_expired_sessions(sessions, current_time) do
  # Remove sessions older than 1 hour (3600 seconds)
  {valid_sessions, expired_count} = cleanup_sessions_helper(sessions, current_time, 0)
  {valid_sessions, expired_count}
end

defp cleanup_sessions_helper(sessions, current_time, expired_count) do
  case sessions do
    %{} -> {%{}, expired_count}
    %{session_id => session_data | rest} ->
      %{created_at: created_at} <- session_data
      if current_time - created_at > 3600 do
        cleanup_sessions_helper(rest, current_time, expired_count + 1)
      else
        {remaining_sessions, count} = cleanup_sessions_helper(rest, current_time, expired_count)
        {%{session_id => session_data | remaining_sessions}, count}
      end
  end
end

defp remove_cache_entry(cache, key) do
  case cache do
    %{} -> %{}
    %{key => _value | rest} -> rest
    %{k => v | rest} -> %{k => v | remove_cache_entry(rest, key)}
  end
end

defp remove_oldest_entry(cache) do
  # Simple implementation - remove first entry
  case cache do
    %{} -> %{}
    %{_key => _value | rest} -> rest
  end
end

defp map_size(map) do
  # Mock map size function
  case map do
    %{} -> 0
    %{_key => _value | rest} -> 1 + map_size(rest)
  end
end

defp integer_to_string(n) do
  "number"
end