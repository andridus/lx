# Functions Examples
# Demonstrates function definitions, multiple clauses, guards, and anonymous functions

def simple_function() do
  "Hello from simple function"
end

def function_with_parameters(name, age) do
  "Name: " ++ name ++ ", Age: " ++ integer_to_string(age)
end

# Multiple clause function
def factorial do
  (0) do 1 end
  (N) when N > 0 do N * factorial(N - 1) end
end

# Multiple clause function with pattern matching
def process_message do
  (:hello) do "Hello there!" end
  ({:user, name}) do "Hello user: " ++ name end
  ({:admin, name, level}) do "Hello admin " ++ name ++ " (level " ++ integer_to_string(level) ++ ")" end
  (_) do "Unknown message" end
end

# Function with guards
def classify_age do
  (age) when age < 13 do "Child" end
  (age) when age >= 13 andalso age < 20 do "Teenager" end
  (age) when age >= 20 andalso age < 65 do "Adult" end
  (age) when age >= 65 do "Senior" end
  (_) do "Invalid age" end
end

# Function with complex guards
def validate_user do
  (%{name: name, age: age}) when name != "" andalso age >= 0 andalso age <= 150 do
    {:ok, "Valid user"}
  end
  (%{name: name, age: _age}) when name == "" do
    {:error, "Name cannot be empty"}
  end
  (%{name: _name, age: age}) when age < 0 or age > 150 do
    {:error, "Invalid age"}
  end
  (_) do
    {:error, "Invalid user data"}
  end
end

# Anonymous functions (fun expressions)
def anonymous_functions() do
  # Basic anonymous function
  add = fn(x, y) do x + y end
  result1 = add(3, 4)

  # Anonymous function as argument
  numbers = [1, 2, 3, 4, 5]
  doubled = map_numbers(numbers, fn(x) do x * 2 end)

  # Anonymous function with closure
  multiplier = 3
  scale = fn(x) do x * multiplier end
  scaled_value = scale(10)

  {result1, doubled, scaled_value}
end

# Multi-clause anonymous function
def multi_clause_anonymous() do
  process = fn do
    (:ok) do "Success" end
    (:error) do "Failed" end
    (_) do "Unknown" end
  end

  results = [
    process(:ok),
    process(:error),
    process(:unknown)
  ]

  results
end

# Anonymous function with guards
def guarded_anonymous() do
  validate = fn do
    (x) when x > 0 do :positive end
    (x) when x < 0 do :negative end
    (0) do :zero end
  end

  test_values = [5, -3, 0, 10, -7]
  classifications = map_numbers(test_values, validate)

  classifications
end

# Higher-order functions
def higher_order_functions() do
  # Function that returns a function
  make_adder = fn(n) do
    fn(x) do x + n end
  end

  add5 = make_adder(5)
  add10 = make_adder(10)

  # Function that takes a function as argument
  apply_twice = fn(f, x) do
    f(f(x))
  end

  double = fn(x) do x * 2 end
  result = apply_twice(double, 3)

  {add5(10), add10(5), result}
end

# Functional composition
def functional_composition() do
  compose = fn(f, g) do
    fn(x) do f(g(x)) end
  end

  add_one = fn(x) do x + 1 end
  multiply_two = fn(x) do x * 2 end
  add_then_multiply = compose(multiply_two, add_one)

  result = add_then_multiply(5)
  result
end

# List processing with anonymous functions
def list_processing() do
  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

  # Filter even numbers and double them
  even_doubled = filter_map(
    numbers,
    fn(x) do x % 2 == 0 end,  # Filter even numbers
    fn(x) do x * 2 end        # Double them
  )

  even_doubled
end

# Private function (defp)
defp map_numbers(list, fun) do
  case list do
    [] -> []
    [head | tail] -> [fun(head) | map_numbers(tail, fun)]
  end
end

defp filter_map(list, predicate, mapper) do
  case list do
    [] -> []
    [head | tail] ->
      if predicate(head) do
        [mapper(head) | filter_map(tail, predicate, mapper)]
      else
        filter_map(tail, predicate, mapper)
      end
  end
end

# Helper function
def integer_to_string(n) do
  "number"
end