## [Unreleased]

### Added
- **Parser Base Structure**: Complete recursive descent parser implementation with token management, error recovery, and precedence table
- **Error Recovery System**: Robust error handling that continues parsing after encountering invalid tokens, synchronizing to block boundaries (def, defp, worker, supervisor, etc.)
- **Expression Parsing**: Comprehensive parsing of literals, variables, assignments, and function calls including external module calls (mod.fun)
- **Data Structures Parsing**: Complete parsing of tuples, lists, cons expressions, and maps with nested structure support
- **Operator Precedence**: Full implementation of operator precedence and associativity for arithmetic, comparison, and logical operators
- **Recovery Strategy**: Parser continues processing multiple expressions even when errors occur, reporting all errors found in the code
- **Guards (when expressions)**: Complete implementation of Erlang-style guards with support for type tests, logical operators (and, or, not, andalso, orelse), and operator conversion (!= to /=, <= to =<)
- **Send operator (!)**: Message passing operator for inter-process communication with proper precedence and AST structure
- **Receive expressions**: Blocking pattern matching for process messages with timeout support and guard expressions
- **Records**: Structured data types with named fields, including creation, field access, updates, and pattern matching
- **Maps**: Key-value data structures with atom keys (colon syntax) and general keys (arrow syntax), including creation, access, and pattern matching
- **Fun expressions**: Anonymous functions with support for single and multi-clause definitions, pattern matching, and closures
- **Binary/Bitstring support**: Complete implementation for binary creation, pattern matching, and type specifications
- **List Comprehensions (for loops)**: Enhanced for loops with guards, pattern matching, and complex data structure iteration
- **Match/Rescue expressions**: Error handling construct with individual and sequential pattern matching steps
- **OTP Components**: Worker and supervisor definitions with validation and proper callback requirements
- **Module System**: Dependency management with global and per-file declarations, type validation via BEAM files
- **Enhanced Pattern Matching**: Support for complex patterns including maps, records, tuples, and nested structures
- **Type System Improvements**: Comprehensive type checking for all new constructs with proper error reporting
- **Logical operators `andalso`/`&&` and `orelse`/`||` now generate `andalso` and `orelse` in Erlang output, matching modern BEAM semantics.
- **Lexer recognizes both symbolic and word forms for these operators.
- **Didactic Examples**: Added a comprehensive set of didactic `.lx` example files in `lxc/examples/`, covering basic to advanced features (syntax, pattern matching, functions, control flow, data structures, OTP, concurrency, specifications, testing, and a full application). All examples follow the official Lx syntax and ensure every expression is inside a function, serving as reference and test material for users and contributors.
- **Lexer Token Refactoring**: Refactored `KeywordToken`, `OperatorToken`, and `PunctuationToken` from enums to structs with a `value` field containing the corresponding enum (`KeywordValue`, `OperatorValue`, `PunctuationValue`). Added helper functions `keyword()`, `operator()`, and `punctuation()` for simplified token creation. This improves type safety and provides a more consistent token structure throughout the lexer and parser.
- **Função utilitária de teste**: Adicionada `assert_lx_generates_erlang(lx_code, expected_erlang)` para facilitar testes automatizados comparando código LX e o Erlang gerado. Permite escrever testes limpos e diretos usando apenas strings, sem manipulação manual de tokens.

### Fixed
- **Fixed lexer negative number handling**: Removed the `maybe_negative` state from the lexer to follow modern compiler design principles. The lexer now always separates the minus operator (`-`) from numbers, leaving the interpretation of negative numbers to the parser phase. This ensures correct tokenization for expressions like `n-1` (which now produces `IdentToken("n")`, `OperatorToken.minus`, `IntToken(1)`) and eliminates ambiguity in complex expressions.
- **Fixed lexer whitespace transitions**: Corrected the whitespace state transitions to properly return to the initial state after consuming whitespace characters. This prevents the lexer from getting stuck in the whitespace state and ensures proper tokenization of code after spaces and newlines.
- **Fixed private function exports**: Corrected Erlang code generation to not export functions defined with `defp` (private functions). Private functions are now properly marked in the AST and excluded from the export list in generated Erlang modules, ensuring they remain internal to the module as intended.
- **Fixed multi-head function parsing**: Corrected parser to properly detect and parse multi-head functions with multiple clauses. The parser now correctly distinguishes between single-head (`def name(params) do ... end`) and multi-head (`def name do ... end`) functions, and properly handles clause boundaries by detecting the `( ... ) ->` pattern without consuming tokens from the next clause.
- Fixed parser error handling to register errors but continue parsing, ensuring all syntax errors are reported
- Fixed parser synchronization to skip tokens until finding block boundaries after encountering errors
- Fixed operator precedence parsing to correctly handle complex expressions with multiple operators
- Fixed data structure parsing to support nested tuples, lists, and maps with proper error recovery
- Fixed `utils.unescape_string` to use `result += s[i..i+1]` for correct string handling, ensuring all foundation tests pass and proper V idioms are followed.
- Fixed string literal parsing in lexer to correctly handle escaped quotes (`\"`) and prevent premature string termination.
- Fixed lexer transitions for strings to properly validate invalid characters (like `@`) within string literals.
- Fixed record update compilation to use correct record type names instead of generic #record syntax
- Fixed map pattern matching to handle mixed key types and provide clear error messages for missing fields
- Fixed guard compilation to properly convert Lx operators to Erlang equivalents
- Fixed send operator precedence and associativity for correct message passing semantics
- Fixed receive expression compilation to generate proper Erlang receive blocks with timeout handling
- Fixed fun expression compilation to support both simple and multi-clause anonymous functions
- Fixed binary pattern matching to handle complex specifications and size expressions
- Fixed OTP validator to properly check required callbacks and component structure
- Fixed module generation to handle dependencies and generate correct Erlang module structure
- Fixed typechecker types tests: corrected module imports, updated usage to match the current typechecker API, and fixed string assertion for function type representation in list context (now expects 'list((T1) -> T2)'). All type system tests now pass.
- Fixed: Assignment parsing in function bodies now correctly accepts `name = "Alice"` and similar statements, matching LX syntax reference. (2024-06-09)